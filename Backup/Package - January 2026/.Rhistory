user <- "Paolo"
if (user == "Paolo") {
setwd("H:/.shortcut-targets-by-id/1X0uTdkzE9LBjtSaGrtrmlSYl7zbqZ7tn/Bosco_Maranzano_Monturano/Codice")
}
if (user == "Server") {
setwd("C:/Users/paolomaranzano/Desktop/SpatReg_RDC/Codice")
}
Imputation <- TRUE
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(imputeTS)
##### Source SCR codes from Sugasawa 2020
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset and shapefile
load("../DB_e_Meta/DB_RDC_RDC.Rdata")
RDC <- DB_COMPLETO_tot
RDC <- RDC %>%
mutate(share_of_rich = case_when(is.na(share_of_rich) ~ 0,
TRUE ~ share_of_rich),
log_NucleiFamTot = log(as.numeric(numero_fam)))
#########################################################################
########## Clustered spatial regression: automatic computation ##########
#########################################################################
# Years of interest
Years_RDC <- 2019:2022
# Years_RDC <- 2022
# Load shapefile
load("../DB_e_Meta/Dichiarazioni_comuni.RData")
# Models specifications
Specs <- read_excel("../DB_e_Meta/Copia di meta_DB_RDC_1spec.xlsx", sheet = "Spec Paolo")
Specs_idx <- 1:5
# Specs_idx <- 5
# Clustering parameters
N_grps <- 1:50
N_ngbh <- c(25,50,100)
Models <- c("poisson")
# Models <- c("gaussian","poisson","NB")
# Paramater grid
Grid_models <- expand.grid(Years_RDC,Specs_idx,N_grps,N_ngbh,Models)
fit <- vector(mode = "list", length = dim(Grid_models)[1])
timing <- matrix(data = NA ,nrow = dim(Grid_models)[1], ncol = 2)
if (Imputation == TRUE) {
vars_interp <- Specs[unique(which(Specs$Spec1 == "Covariate" |
Specs$Spec1 == "Covariate lagged")),1] %>%
pull()
RDC_interp <- RDC %>%
group_by(istat.x) %>%
arrange(Anno) %>%
mutate(across(c(vars_interp), ~ case_when(mean(is.na(.x)) == 1 ~ 999999,
sum(!is.na(.x)) == 1 ~ ifelse(is.na(.x),666666,.x),
TRUE ~ .x))) %>%
mutate(across(c(vars_interp), ~ case_when(.x == 999999 ~ NA_real_,
.x == 666666 ~ ifelse(.x == 666,NA_real_,as.numeric(.x)),
sum(!is.na(.x)) >= 2 ~ na_interpolation(.x,option = "spline"),
TRUE ~ .x))) %>%
ungroup()
save(RDC_interp,file = "../DB_e_Meta/DB_RDC_RDC_imputed.Rdata")
} else {
load("../DB_e_Meta/DB_RDC_RDC_imputed.Rdata")
}
##### Select only relevant variables
Vars <- Specs %>%
pivot_longer(cols = 2:last_col(), names_to = "Spec", values_to = "Role") %>%
filter(!is.na(Role)) %>%
distinct(names.Panel.) %>%
pull()
citation(package = "SCDA")
citation(package = "base")
View(RDC_interp)
##### Simulate RdC data following a Poisson random variable
set.seed(1234)
RDC_interp_masked <- RDC_interp %>%
dplyr::select(1:21,32,all_of(Vars)) %>%
mutate(Nuclei_pesati_RdC = rpois(n = length(Nuclei_pesati_RdC),
lambda = mean(Nuclei_pesati_RdC,na.rm=T)))
##### Store masked dataset
save(RDC_interp_masked,file = "../DB_e_Meta/PM_GM_PT_IEJ2025_RdCSpatClust.Rdata")
gc()
########################################################################################################
##########                            Replication code for                                    ##########
##########    "The Geography of the Italian Citizenship Income:                               ##########
##########    the Role of Poverty and Inequality in Determining Spatial Heterogeneity across  ##########
##########    the Italian Municipalities" (Italian Economic Journal, 2025)                    ##########                                                    ##########
##########            Paolo Maranzano (UniMiB)                                                ##########
##########            Gianluca Monturano (UniBa)                                              ##########
##########            Pasquale Tridico (UniRoma3)                                             ##########
##########      Part II: analysis of the empirical results                                    ##########
########################################################################################################
##### Setup
setwd("~/GitHub/PM_GM_PT_IEJ2025_RdCSpatClust")
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(ggpubr)
##### Source SCR codes from Sugasawa 2021
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset
load("PM_GM_PT_IEJ2025_RdCSpatClust - Data.Rdata")
##### Shapefile
load("Dichiarazioni_comuni.RData")
##### Specifications
Specs <- read_excel("Meta_DB_RDC.xlsx", sheet = "Spec Paolo")
##### Specifications
Specs <- read_excel("Meta_DB_RDC.xlsx", sheet = "Spec Paolo")
##### Shapefile
load("Dichiarazioni_comuni.RData")
########################################################################################################
##########                            Replication code for                                    ##########
##########    "The Geography of the Italian Citizenship Income:                               ##########
##########    the Role of Poverty and Inequality in Determining Spatial Heterogeneity across  ##########
##########    the Italian Municipalities" (Italian Economic Journal, 2025)                    ##########                                                    ##########
##########            Paolo Maranzano (UniMiB)                                                ##########
##########            Gianluca Monturano (UniBa)                                              ##########
##########            Pasquale Tridico (UniRoma3)                                             ##########
##########      Part II: analysis of the empirical results                                    ##########
########################################################################################################
##### Setup
setwd("~/GitHub/PM_GM_PT_IEJ2025_RdCSpatClust")
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(ggpubr)
##### Source SCR codes from Sugasawa 2021
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset
load("PM_GM_PT_IEJ2025_RdCSpatClust - Data.Rdata")
##### Shapefile
load("Shape_comuni.RData")
##### Specifications
Specs <- read_excel("Meta_DB_RDC.xlsx", sheet = "Spec Paolo")
load("H:/.shortcut-targets-by-id/1X0uTdkzE9LBjtSaGrtrmlSYl7zbqZ7tn/Bosco_Maranzano_Monturano/Codice/OutputComplete_Specs_12345_2019202020212022.RData")
##### Binding
ICs <- ICs %>%
mutate(Spec_lab = paste0("Spec.",Spec),
N_ngbh_lab = paste0("Neighbors = ",N_ngbh),
N_ngbh_lab = factor(N_ngbh_lab,
levels = c("Neighbors = 25","Neighbors = 50","Neighbors = 100"),
labels = c("Neighbors = 25","Neighbors = 50","Neighbors = 100"),ordered = T))
##### Select the year of interest
YR <- 2020
cols <- c("Spec.1" = "black", "Spec.2" = "#3399FF", "Spec.3" = "#FF3333",
"Spec.4" = "#006633","Spec.5" = "#0000FF", "Spec.6" = "#FF9933")
##### Idnetificazione dei modelli con minori ICs
# Indicazione 5: BIC suggerisce modelli più parsimoniosi (minor numero di gruppi) rispetto HQ e AIC
# Indicazione 6: Secondo BIC, i modelli migliori sono tra 20, 25 e 26 gruppi
#       --> Parsimonia perchè le performance sono molto simili
# Indicazione 7: con il passare del tempo, il numero ottimo di gruppi aumenta (quasi raddoppia)
#       --> Aumento dell'eterogeneità degli effetti
ICs_min <- ICs %>%
group_by(Year,Spec,Response,N_ngbh) %>%
mutate(minBIC = min(BIC),minAIC = min(AIC),minHQ = min(HQ)) %>%
ungroup() %>%
add_rownames()
ICs_min[which(ICs_min$BIC == ICs_min$minBIC),] %>% arrange(BIC) %>% View()
ICs_min[which(ICs_min$AIC == ICs_min$minAIC),] %>% arrange(AIC)
ICs_min[which(ICs_min$HQ == ICs_min$minHQ),] %>% arrange(HQ)
ICs %>%
filter(N_grps >= 5) %>%
pivot_longer(cols = c("BIC"), names_to = "IC", values_to = "Value") %>%
ggplot() +
geom_line(mapping = aes(x = N_grps, y = Value, col = Spec_lab)) +
geom_point(mapping = aes(x = N_grps, y = Value, col = Spec_lab)) +
ggh4x::facet_grid2(rows = vars(Year), cols = vars(as.factor(N_ngbh_lab)), scales = "free", independent = "y") +
geom_vline(data = ICs_min %>% filter(BIC == minBIC),
mapping = aes(xintercept = N_grps, col = Spec_lab), linewidth = 1.2) +
# ggh4x::facet_grid2(rows = vars(Year), cols = vars(as.factor(N_ngbh))) +
scale_color_manual("Specification", values = cols) +
labs(title = "Bayesian Information Criterion (BIC) by number of clusters, neighbors, and year",
x = "Number of clusters", y = "BIC") +
theme_bw() +
theme(plot.title = element_text(face = "bold", size = 20),
axis.title = element_text(size = 14))
########################################################################################################
##########                            Replication code for                                    ##########
##########    "The Geography of the Italian Citizenship Income:                               ##########
##########    the Role of Poverty and Inequality in Determining Spatial Heterogeneity across  ##########
##########    the Italian Municipalities" (Italian Economic Journal, 2025)                    ##########                                                    ##########
##########            Paolo Maranzano (UniMiB)                                                ##########
##########            Gianluca Monturano (UniBa)                                              ##########
##########            Pasquale Tridico (UniRoma3)                                             ##########
##########    Part I: estimating the SCR-Poisson models                                       ##########
########################################################################################################
##### Setup
setwd("~/GitHub/PM_GM_PT_IEJ2025_RdCSpatClust")
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(ggpubr)
##### Source SCR codes from Sugasawa 2021
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset
load("PM_GM_PT_IEJ2025_RdCSpatClust - Data.Rdata")
##### Shapefile
load("Shape_comuni.RData")
##### Specifications
Specs <- read_excel("Meta_DB_RDC.xlsx", sheet = "Spec Paolo")
#########################################################################
########## Clustered spatial regression: automatic computation ##########
#########################################################################
# Years of interest
Years_RDC <- 2019:2022
# Models specifications
Specs_idx <- 1:5
# Clustering parameters
N_grps <- 1:50
N_ngbh <- c(25,50,100)
Models <- c("poisson")
# Paramater grid
Grid_models <- expand.grid(Years_RDC,Specs_idx,N_grps,N_ngbh,Models)
fit <- vector(mode = "list", length = dim(Grid_models)[1])
timing <- matrix(data = NA ,nrow = dim(Grid_models)[1], ncol = 2)
m <- 1
t1 <- Sys.time()
cat(paste0("Iteration: ",m," of ",dim(Grid_models)[1], ": ",
"Year = ",Grid_models[m,1]," -- Spec = ",Grid_models[m,2]," -- ",
"Nghb = ",Grid_models[m,4]," -- NumGrps = ",Grid_models[m,3],
" started at in ",t1,"\n"))
if (Grid_models[m,1] != 2022) {
shape <- data_sp %>%
filter(Year == Grid_models[m,1]) %>%
dplyr::select(ISTAT_Code_LAU)
} else {
shape <- data_sp %>%
filter(Year == 2021) %>%
dplyr::select(ISTAT_Code_LAU)
}
fit[[m]] <- SCR_OptimEstim(Dataset = RDC_interp,
Grid_models = Grid_models,
optim_idx = m,
Specs = Specs)$fit_optim
fit[[m]] <- SCR_OptimEstim(Dataset = RDC_interp_masked,
Grid_models = Grid_models,
optim_idx = m,
Specs = Specs)$fit_optim
RDC_interp_masked
########################################################################################################
##########                            Replication code for                                    ##########
##########    "The Geography of the Italian Citizenship Income:                               ##########
##########    the Role of Poverty and Inequality in Determining Spatial Heterogeneity across  ##########
##########    the Italian Municipalities" (Italian Economic Journal, 2025)                    ##########                                                    ##########
##########            Paolo Maranzano (UniMiB)                                                ##########
##########            Gianluca Monturano (UniBa)                                              ##########
##########            Pasquale Tridico (UniRoma3)                                             ##########
##########    Part I: data manipulation and cleaning                                          ##########
########################################################################################################
##### Setup
user <- "Paolo"
if (user == "Paolo") {
setwd("H:/.shortcut-targets-by-id/1X0uTdkzE9LBjtSaGrtrmlSYl7zbqZ7tn/Bosco_Maranzano_Monturano/Codice")
}
if (user == "Server") {
setwd("C:/Users/paolomaranzano/Desktop/SpatReg_RDC/Codice")
}
Imputation <- TRUE
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(imputeTS)
##### Source SCR codes from Sugasawa 2020
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset and shapefile
load("../DB_e_Meta/DB_RDC_RDC.Rdata")
RDC <- DB_COMPLETO_tot
RDC <- RDC %>%
mutate(share_of_rich = case_when(is.na(share_of_rich) ~ 0,
TRUE ~ share_of_rich),
log_NucleiFamTot = log(as.numeric(numero_fam)))
#########################################################################
########## Clustered spatial regression: automatic computation ##########
#########################################################################
# Years of interest
Years_RDC <- 2019:2022
# Years_RDC <- 2022
# Load shapefile
load("../DB_e_Meta/Dichiarazioni_comuni.RData")
# Models specifications
Specs <- read_excel("../DB_e_Meta/Copia di meta_DB_RDC_1spec.xlsx", sheet = "Spec Paolo")
Specs_idx <- 1:5
# Specs_idx <- 5
# Clustering parameters
N_grps <- 1:50
N_ngbh <- c(25,50,100)
Models <- c("poisson")
# Models <- c("gaussian","poisson","NB")
# Paramater grid
Grid_models <- expand.grid(Years_RDC,Specs_idx,N_grps,N_ngbh,Models)
fit <- vector(mode = "list", length = dim(Grid_models)[1])
timing <- matrix(data = NA ,nrow = dim(Grid_models)[1], ncol = 2)
vars_interp <- Specs[unique(which(Specs$Spec1 == "Covariate" |
Specs$Spec1 == "Covariate lagged")),1] %>%
pull()
RDC_interp <- RDC %>%
group_by(istat.x) %>%
arrange(Anno) %>%
mutate(across(c(vars_interp), ~ case_when(mean(is.na(.x)) == 1 ~ 999999,
sum(!is.na(.x)) == 1 ~ ifelse(is.na(.x),666666,.x),
TRUE ~ .x))) %>%
mutate(across(c(vars_interp), ~ case_when(.x == 999999 ~ NA_real_,
.x == 666666 ~ ifelse(.x == 666,NA_real_,as.numeric(.x)),
sum(!is.na(.x)) >= 2 ~ na_interpolation(.x,option = "spline"),
TRUE ~ .x))) %>%
ungroup() %>%
mutate(share_of_rich = case_when(is.na(share_of_rich) ~ 0,
TRUE ~ share_of_rich),
log_NucleiFamTot = log(as.numeric(numero_fam)))
View(RDC_interp)
save(RDC_interp,file = "../DB_e_Meta/DB_RDC_RDC_imputed.Rdata")
##### Select only relevant variables
Vars <- Specs %>%
pivot_longer(cols = 2:last_col(), names_to = "Spec", values_to = "Role") %>%
filter(!is.na(Role)) %>%
distinct(names.Panel.) %>%
pull()
##### Simulate RdC data following a Poisson random variable
set.seed(1234)
RDC_interp_masked <- RDC_interp %>%
dplyr::select(1:21,32,all_of(Vars),157,) %>%
mutate(Nuclei_pesati_RdC = rpois(n = length(Nuclei_pesati_RdC),
lambda = mean(Nuclei_pesati_RdC,na.rm=T)))
##### Store masked dataset
save(RDC_interp_masked,file = "../DB_e_Meta/PM_GM_PT_IEJ2025_RdCSpatClust.Rdata")
##### Store masked dataset
save(RDC_interp_masked,file = "../DB_e_Meta/PM_GM_PT_IEJ2025_RdCSpatClust - Data.Rdata")
########################################################################################################
##########                            Replication code for                                    ##########
##########    "The Geography of the Italian Citizenship Income:                               ##########
##########    the Role of Poverty and Inequality in Determining Spatial Heterogeneity across  ##########
##########    the Italian Municipalities" (Italian Economic Journal, 2025)                    ##########                                                    ##########
##########            Paolo Maranzano (UniMiB)                                                ##########
##########            Gianluca Monturano (UniBa)                                              ##########
##########            Pasquale Tridico (UniRoma3)                                             ##########
##########      Part II: analysis of the empirical results                                    ##########
########################################################################################################
##### Setup
setwd("~/GitHub/PM_GM_PT_IEJ2025_RdCSpatClust")
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(ggpubr)
##### Source SCR codes from Sugasawa 2021
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset
load("PM_GM_PT_IEJ2025_RdCSpatClust - Data.Rdata")
##### Shapefile
load("Shape_comuni.RData")
##### Specifications
Specs <- read_excel("Meta_DB_RDC.xlsx", sheet = "Spec Paolo")
#############################################
############### Data analysis ###############
#############################################
##### Binding
ICs <- ICs %>%
mutate(Spec_lab = paste0("Spec.",Spec),
N_ngbh_lab = paste0("Neighbors = ",N_ngbh),
N_ngbh_lab = factor(N_ngbh_lab,
levels = c("Neighbors = 25","Neighbors = 50","Neighbors = 100"),
labels = c("Neighbors = 25","Neighbors = 50","Neighbors = 100"),ordered = T))
load("H:/.shortcut-targets-by-id/1X0uTdkzE9LBjtSaGrtrmlSYl7zbqZ7tn/Bosco_Maranzano_Monturano/Codice/OutputComplete_Specs_12345_2019202020212022.RData")
##### Binding
ICs <- ICs %>%
mutate(Spec_lab = paste0("Spec.",Spec),
N_ngbh_lab = paste0("Neighbors = ",N_ngbh),
N_ngbh_lab = factor(N_ngbh_lab,
levels = c("Neighbors = 25","Neighbors = 50","Neighbors = 100"),
labels = c("Neighbors = 25","Neighbors = 50","Neighbors = 100"),ordered = T))
##### Select the year of interest
YR <- 2020
cols <- c("Spec.1" = "black", "Spec.2" = "#3399FF", "Spec.3" = "#FF3333",
"Spec.4" = "#006633","Spec.5" = "#0000FF", "Spec.6" = "#FF9933")
##### Idnetificazione dei modelli con minori ICs
# Indicazione 5: BIC suggerisce modelli più parsimoniosi (minor numero di gruppi) rispetto HQ e AIC
# Indicazione 6: Secondo BIC, i modelli migliori sono tra 20, 25 e 26 gruppi
#       --> Parsimonia perchè le performance sono molto simili
# Indicazione 7: con il passare del tempo, il numero ottimo di gruppi aumenta (quasi raddoppia)
#       --> Aumento dell'eterogeneità degli effetti
ICs_min <- ICs %>%
group_by(Year,Spec,Response,N_ngbh) %>%
mutate(minBIC = min(BIC),minAIC = min(AIC),minHQ = min(HQ)) %>%
ungroup() %>%
add_rownames()
ICs_min[which(ICs_min$BIC == ICs_min$minBIC),] %>% arrange(BIC) %>% View()
ICs_min[which(ICs_min$AIC == ICs_min$minAIC),] %>% arrange(AIC)
ICs_min[which(ICs_min$HQ == ICs_min$minHQ),] %>% arrange(HQ)
##### Ristima del modello ottimo
# Grid model e specifications
Years_RDC <- 2019:2022
Specs_idx <- c(1:6)
N_grps <- 1:50
N_ngbh <- c(25,50,100)
Models <- c("poisson")
Grid_models <- expand.grid(Years_RDC,Specs_idx,N_grps,N_ngbh,Models)
shape <- data_sp %>%
filter(Year == YR) %>%
dplyr::select(ISTAT_Code_LAU)
ICs_min %>%
filter(BIC == minBIC,Spec==3, N_ngbh == 25) %>%
View()
# Select the optimal model parameters
optim_idx <- which(Grid_models$Var3 == 25 & Grid_models$Var4 == 25 & Grid_models$Var2 == 3)
optim_idx <- ICs_min %>%
filter(BIC == minBIC,Spec==3, N_ngbh == 25) %>%
dplyr::select(rowname) %>%
pull()
##### Define colors scale by variable
Cols_beta <- vector(mode = "list", length = 5)
Cols_beta_m <- vector(mode = "list", length = 4)
Cols_beta_m_j <- vector(mode = "list", length = 3)
spec_num <- 1
estimate <- TRUE
optim_idx <- ICs_min %>%
filter(BIC == minBIC, N_ngbh == 25, Spec == spec_num)
n_mods <- dim(optim_idx)[1]
fit_optim <- vector(mode = "list", length = n_mods)
Years <- c(2019,2020,2021,2022)
variables <- c("Gini_con_0_lag1","Redditi_Procapite_lag1","share_of_poverty_lag1")
variables_label <- c("Gini index (lagged)","Per capita income (lagged)","Share of poverty (lagged)")
plot_res <- vector(mode = "list", length = n_mods)
m <- 1
##### Estimation
cat(paste0("Model ",m," of ",n_mods,": estimating","\n"))
fit_optim[[m]] <- SCR_OptimEstim(Dataset = RDC_interp_masked,
Grid_models = ICs,
optim_idx = as.numeric(optim_idx[m,"rowname"]),
Specs = Specs)
mod <- fit_optim[[m]]
########################################################################################################
##########                            Replication code for                                    ##########
##########    "The Geography of the Italian Citizenship Income:                               ##########
##########    the Role of Poverty and Inequality in Determining Spatial Heterogeneity across  ##########
##########    the Italian Municipalities" (Italian Economic Journal, 2025)                    ##########                                                    ##########
##########            Paolo Maranzano (UniMiB)                                                ##########
##########            Gianluca Monturano (UniBa)                                              ##########
##########            Pasquale Tridico (UniRoma3)                                             ##########
##########    Part I: estimating the SCR-Poisson models                                       ##########
########################################################################################################
##### Setup
setwd("~/GitHub/PM_GM_PT_IEJ2025_RdCSpatClust")
##### Libraries
library(tidyverse)
library(sf)
library(spatialreg)
library(readxl)
library(spdep)
library(ggpubr)
##### Source SCR codes from Sugasawa 2021
source("SCR-main/SCR-function.R", encoding = 'UTF-8')
source("SCR-main/AuxFn - SCR_OptimEstim.R", encoding = 'UTF-8')
##### Dataset
load("PM_GM_PT_IEJ2025_RdCSpatClust - Data.Rdata")
##### Shapefile
load("Shape_comuni.RData")
##### Specifications
Specs <- read_excel("Meta_DB_RDC.xlsx", sheet = "Spec Paolo")
#########################################################################
########## Clustered spatial regression: automatic computation ##########
#########################################################################
# Years of interest
Years_RDC <- 2019:2022
# Models specifications
Specs_idx <- 1:5
# Clustering parameters
N_grps <- 1:50
N_ngbh <- c(25,50,100)
Models <- c("poisson")
# Paramater grid
Grid_models <- expand.grid(Years_RDC,Specs_idx,N_grps,N_ngbh,Models)
fit <- vector(mode = "list", length = dim(Grid_models)[1])
timing <- matrix(data = NA ,nrow = dim(Grid_models)[1], ncol = 2)
m <- 1
t1 <- Sys.time()
cat(paste0("Iteration: ",m," of ",dim(Grid_models)[1], ": ",
"Year = ",Grid_models[m,1]," -- Spec = ",Grid_models[m,2]," -- ",
"Nghb = ",Grid_models[m,4]," -- NumGrps = ",Grid_models[m,3],
" started at in ",t1,"\n"))
if (Grid_models[m,1] != 2022) {
shape <- data_sp %>%
filter(Year == Grid_models[m,1]) %>%
dplyr::select(ISTAT_Code_LAU)
} else {
shape <- data_sp %>%
filter(Year == 2021) %>%
dplyr::select(ISTAT_Code_LAU)
}
fit[[m]] <- SCR_OptimEstim(Dataset = RDC_interp_masked,
Grid_models = Grid_models,
optim_idx = m,
Specs = Specs)$fit_optim
